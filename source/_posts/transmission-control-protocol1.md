---
title: 传输控制协议（1）连接与释放
date: 2016-08-10 15:38:47
tags:
- 计算机网络
- 运输层
- TCP
categories:
- 计算机网络
mathjax: true
---

## TCP首部字段

![TCP首部字段](TCP_header.png)

+ 16位源端口：用来实现TCP的分用，根据端口的不同，将数据上交给不同的上层应用。

+ 16位目的端口：同上。

+ 32位序号：对数据进行编号，每个字节的数据都要消耗一个的编号,编号的范围是[0, 2^32-1]，编号增加到2^32-1后，编号就会变成0重新开始。首部中序号表示该次传输的数据的第一个字节的编号，比如第一次传输数据传输了100个字节，那么这些数据的编号是[0，99]，所以首部中序号应该填写0；第二次传输数据传输了100个字节，那么这些数据的编号是[100,199]，所以首部中序号应该填写100。

+ 32位确认号：对收到的数据进行确认，也可以表示期望对方下一个报文段的第一个字节数据的序号。比如A第一次传输了100个字节的数据给B，那么B对其确认时，确认号为100，表明序号100以前的数据我都收到了，B期望收到A的下一个数据的序号是100。
> 如果确认号 = N，则表明到序号N - 1的所有数据已经正确收到。

+ 4位首部长度：4位二进制能够表示的最大数是15，而首部长度的单位是4个字节，所以首部长度最大值是60个字节。也就是说选项长度不能超过40个字节。

+ 6位保留：保留字段，现在还没有使用，所以应该置为0。确定有保留字段，扩展性就变强了。

+ 1位URG：该URG = 1时，说明该报文段中存在紧急数据。具体哪一个字节是紧急数据，由16位紧急指针指定。

+ 1位ACK：当ACK = 1时，确认号字段才有效，当ACK = 0时，确认号无效。TCP规定，连接建立之后，所有传送的报文都必须把ACK置为1。

+ 1位PSH：立即发送缓冲区内的所有数据，无需等待缓冲区中的数据到达了MSS的大小再发送。

+ 1位RST：当RST = 1时， 表明这是一个复位报文，当收到此报文时，表明TCP连接出现了错误，需要马上释放连接。

+ 1位SYN：当SYN = 1时，表示该报文是与建立TCP连接有关的报文。

+ 1位FIN：当FIN = 1时，表示该报文是与释放TCP连接有关的报文。

+ 16位窗口大小：窗口字段指出了现在允许对方发送的数据量。窗口值经常在动态变化着。

+ 16位检验和：对伪首部 + TCP首部 + 数据部分进行16位反码求和，然后取反的结果填写在该字段。接收方对收到的数据同样进行伪首部 + TCP首部 + 数据部分的16伪反码求和，如果最后结果的每一位都是1表明数据在传输的过程中没有出现错误。计算的方法和UDP首部检验和的计算方法一样，具体见 [UDP首部检验和](/2016/08/08/udp-header-check-sum/)

+ 16位紧急指针：其实存储的是一个TCP序列号，指明这个报文中的哪个字节的数据是紧急数据。也就是说一次只要发送一个字节的紧急数据。

+ 选项： 常用的选项有①MSS最大报文段，双方连接时会在SYN报文的选择说明各自的MSS，然后此后发送数据都会选择两者中较小的MSS作为自己的MSS。
## TCP连接的建立

> how are you ?		&nbsp;&nbsp;&nbsp;&nbsp;(SYN)
> fine.And you?		&nbsp;&nbsp;&nbsp;&nbsp;(SYN + ACK)
> Fine.				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(ACK)

![三次握手流程图](TCP_three_shake_hands.png)

1. 客户发送一个报文给服务器，该报文的SYN = 1，seq = x。表明这是连接请求的报文。虽然不携带数据，但是要消耗一个序号。发送完该报文之后，客户端变成**SYN\_Send**状态。

2. 服务器收到该报文之后，发现这是一个连接请求的报文，发送一个确认报文给客服，该报文的SYN = 1，ACK = 1，seq = y，ack\_num = x + 1。表明这是一个对连接请求的确认报文。虽然不携带数据，但是要消耗一个序号。发送完该报文之后，服务器处于**SYN_Reveive**状态。客户端收到该报文之后变成**established**状态。

3. 客户收到服务器的确认报文之后，也要发送一个报文给服务器。该报文的的ACK = 1，seq = x + 1，ack\_num = y + 1。也就你认为上面两步已经够了，但是这一步是很有必要的。只有一个ACK字段置为1，所以这是一个纯粹的确认包，TCP规定，如果确认包不携带数据，那么不消耗序号。服务器收到该报文后变成**established**状态。


为什么需要三次握手呢，第三次握手的作用是什么呢？
假设只有两次握手，那么会发送什么影响呢？也即如果客户端发送SYN请求报文，服务器发送ACK报文就可以建立连接，那么会发送什么事情呢？
+ 客户端发送SYN报文给服务器，如果客户端没有收到服务器发来的ACK报文，那么重传计时器到期了就会重传SYN报文，那么这样看来对于客户端好像没什么影响。
+ 服务器发送ACK报文给客户端，如果ACK报文丢失，那么客户端会重传SYN报文，所以ACK报文丢失对服务器端也没什么影响。那么换个角度来看，如果传来的SYN报文有问题呢，那么如果服务器发送了ACK报文就建立连接，就会白白浪费服务器的资源。那么为什么发来的SYN报文会有问题呢？

**谢希仁的《计算机网络》说： 已失效的连接请求报文段突然又传给server**

> “已失效的连接请求报文段”的产生在这样一种情况下：client发出的第一个连接请求报文段并没有丢失，而是在某个网络结点长时间的滞留了，以致延误到连接释放以后的某个时间才到达server。本来这是一个早已失效的报文段。但server收到此失效的连接请求报文段后，就误认为是client再次发出的一个新的连接请求。于是就向client发出确认报文段，同意建立连接。假设不采用“三次握手”，那么只要server发出确认，新的连接就建立了。由于现在client并没有发出建立连接的请求，因此不会理睬server的确认，也不会向server发送ack包。（此时因为client没有发起建立连接请求，所以client处于CLOSED状态，接受到任何包都会丢弃，谢希仁举的例子就是这种场景）但server却以为新的运输连接已经建立，并一直等待client发来数据。这样，server的很多资源就白白浪费掉了。采用“三次握手”的办法可以防止上述现象发生。例如刚才那种情况，client不会向server的确认发出确认。server由于收不到确认，就知道client并没有要求建立连接。


所以说第三次握手的目的是为了确保客户端收到了SYN报文。

三次握手是确保建立连接的双发都收到了SYN报文。第二次握手是为了确保服务器收到SYN报文，而第三次握手是为了确保客户端收到了SYN报文。

1. 客户端发送了SYN报文给服务器，那么客户端此时期望收到服务器的SYN+ACK报文，如果重传计时器到期了还没有收到SYN+ACK报文，那么就重传SYN报文给服务器。这么做的目的是为了确保自己发送的连接请求能够成功到达服务器。

2. 服务器发送SYN+ACK报文给客户端，那么服务器此时期望收到客户端的ACK报文，如果重传计时器到期了还没有收到ACK报文，那么就重传SYN+ACK报文给客户端，这么做的目的是为了确保自己发送的确认连接请求的报文能够成功到达客户端。

3. 客户端发送ACK报文给服务器，是为了让服务器知道其发送的SYN+ACK报文已经被客户端收到了。这个ACK报文丢失是没有什么关系的，①如果服务器在重传计时器期限内没有收到客户端的ACK报文，那么服务器就重传SYN+ACK报文给客户端就好了；②TCP规定，连接建立成功发送数据时，需要将ACK位置为1，所以客户端给服务器发送数据时，服务器会马上从**SYN\-Receive**状态切换到**established**状态，然后处理接收到的数据。

如果不理解，那么可以看[tcp 编程中，connect 连接成功的标准是什么？](https://www.zhihu.com/question/49619919/answer/116941333)。


## TCP连接的释放

![TCP四次挥手流程](TCP_four_shake_hands.png)

TCP释放连接为什么需要四次挥手呢，因为TCP是全双工的，也即在同一时刻A可以给B传数据，B也可以给A传数据。A传完数据想要关闭连接时，并不代表B也传完数据，也要关闭连接，所以A->B方向的连接和B->A方向的连接需要分别单独关闭。每个方向连接的关闭需要两次挥手，所以加起来就是四次挥手。


