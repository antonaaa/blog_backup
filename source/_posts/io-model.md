---
title: Unix五种网络IO模型 
date: 2016-08-24 12:00:18
tags:
- 操作系统
- IO
categories:
- 操作系统
---

一个socket读取操作分为两个阶段
1. 等待数据准备好，即数据从网络中到达，并且被复制到内核中的某个缓冲区。
2. 将数据从内核缓冲区复制到用户进程。

<!-- more -->
根据这两个阶段的不同，Unix下有五种IO模型，分别是：
+ 阻塞（blocking）式IO
+ 非阻塞（nonblocking）式IO
+ IO复用（multiplexing）
+ 信号驱动（signal driven）IO
+ 异步（asynchronous）IO


## 阻塞式IO
socket的`recv`和`recvfrom`读取数据的操作默认都是阻塞的。
第一个阶段**无数据准备好** 到 **数据准备好**，这个阶段是阻塞的。
第二个阶段**将数据从内核复制到用户进程也是阻塞的**。
最后函数返回时，返回读取到的数据。这两个阶段阻塞时，进程什么事情都不能做，只有当函数返回时，程序才能继续执行。

![阻塞式IO流程图](blocking.png)

## 非阻塞式IO
非阻塞IO和阻塞IO的区别在于第一个阶段，当调用`recvfrom`函数发现数据没有准备好时，函数立即返回一个错误标记。
为了时数据来时程序能够及时处理，所以必须不断调用`recvfrom`函数轮询CPU数据准备好了没，轮询会占据很多的CPU资源，效率不高。
不过相对于阻塞IO，非阻塞式IO可以在等待数据阶段做一些其它的事情。

![非阻塞式IO流程图](nonblocking.png)


## IO复用
select、poll、epool系统调用可以监听多个socket文件描述符。
第一个阶段如果数据没有准备好，同样是会被阻塞。只要监听的socket文件描述符有一个数据准备好了。那么就返回。
第二阶段调用那些数据准备好的socket的`recvfrom`函数，因为数据准备好了，所以直接将数据从内核拷贝到用户进程，而无需进入数据等待阶段。
IO复用的好处在于一个进程可以处理多个socket连接。为什么可以处理多个连接的，因为将数据从内核缓冲区复制到用户进程是很快的。
![IO复用流程图](multiplexing.png)

## 信号驱动IO
首先调用`sigaction`函数设置**SIGIO**信号的处理函数，那么当数据准备好时，操作系统就会发出**SIGIO**信号，应用进程收到该信号之后就会发生中断，即不往下执行程序，而是转去执行该信号的处理函数，在信号处理函数调用socket的`recvfrom`函数，因为数据准备好了，所以直接将数据从内核缓冲区拷贝到用户进程，而无需进入数据等待阶段。
![信号驱动IO流程图](signal_driven.png)

## 异步IO
用户进程发出一个异步IO调用之后就立即返回了，进程可以继续执行其它代码。内核会等待数据准备好，并将数据从内核拷贝到用户进程。完成这些操作后，内核会发出相应的信号，那么用户进程就会调用信号处理程序处理内核拷贝到用户进程的数据。
异步IO和信号驱动IO的区别在于发出信号的时机不同，异步IO是内核将数据拷贝到用户进程后发出信号；而信号驱动IO是数据准备好后发出信号，接下来仍旧需要用户进程调用`recvfrom`函数读取数据。
![异步IO流程图](async.png)


## 同步IO模型和异步IO模型
+ 同步IO操作会导致请求进程阻塞，直到IO操作完成。
+ 异步IO操作不会导致请求进程阻塞。

上面的前4种IO模型都是同步IO模型，前4种IO模型的区别在于第一阶段数据等待，在该阶段有的会导致阻塞，有的不会；但是它们的第二阶段都是一样的，都要将数据从内核缓冲区复制到用户进程，所以前4种IO模型的第二阶段都会导致进程阻塞于`recvfrom`调用。

而异步IO模型在这两个阶段都要处理，并不会导致用户进程阻塞。




<br />

参考：
+ [IO - 同步，异步，阻塞，非阻塞 （亡羊补牢篇）](http://blog.csdn.net/historyasamirror/article/details/5778378)
+ [怎样理解阻塞非阻塞与同步异步的区别？](https://www.zhihu.com/question/19732473)

