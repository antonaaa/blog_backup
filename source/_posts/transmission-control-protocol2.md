---
title: 传输控制协议（2）可靠传输
date: 2016-08-11 21:48:53
tags:
- 计算机网络
- 运输层
- TCP

categories:
- 计算机网络
---


## TCP如何保证可靠传输

要保证可靠传输，那么就要保证下面这两个条件成立

1. 传输信道不会产生差错
2. 不管发送方以多快的速率发送数据，接收方总是来得即处理接收到的数据。

<!-- more -->
但是这两个条件是不会成立的。但是我们可以通过一些协议，使得

1. 当出现差错时，让发送方重传出现差错的数据。 简单得来说就是**超时重传**。
2. 接收方来不及处理数据时，及时告诉发送方适当降低发送数据的速度。  简单得来说就是**流量控制**。


## 超时重传
TCP要求接收方对收到的每个分组都发送一个确认报文。
TCP会对每个发送的分组启动一个**重传计时器**，如果在重传计时器到期之前收到了对方的确认，那么就会撤销计时器；如果在重传计时器到期之前还没有收到对方的确认报文，就会重发该分组。所以

+ 发送方必须保留每个发送分组的副本，直到收到对方发来的对于该分组的确认报文，才能够丢弃该报文。
+ 重传计时器设置的重传时间应该比分组传输的**平均往返时间**更长一些。该超时时间选择肯定不是一个定值，而是通过一个自适应算法计算出来的。

这种自动重传分组的协议成为ARQ(Automatic Repeat reQuset)协议，即接收方不用请求发送方重传某个出错的分组。

**ARP协议分为停止等待(stop-and-wait)ARQ、回退n帧(go-back-n)ARQ、选择性重传(selective repeat)ARQ。**

后两种ARQ又叫做连续ARQ，因为后两种ARQ允许同时发送连续的若干个分组。
### 停止等待ARQ协议

停止等待ARQ协议如下图非常简单，A发送一个分组给B，如果A没有接收到B对于该分组的确认报文，那么就不会继续发送下一个分组，如果在超时时间内收到了确认报文，那么就继续发送下一个分组；如果在超时时间内没有收到该分组的确认报文，那么就重传该分组。

![停止等待协议](stop_waitting_protocol.png)

如果B收到了A发送的报文M1，并且发送了对M1报文的确认报文，但是该确认报文在传输过程中丢失了或者迟到了。那么该怎么处理呢？
+ 确认丢失：那么A会重传报文M1，B接收到M1后就知道A没有收到确认报文，所以就重发确认报文，并且丢弃这个重复的M1分组。
+ 确认迟到：在超时计时器的期限内没有收到对报文M1的确认报文，那么A会重传报文M1，B接收到M1后就知道A没有收到确认报文，所以重发确认报文，并且丢弃这个重复的M1报文。那么A可能会收到两个对M1的确认报文，那么A只要丢弃重复的确认报文即可。

![确认丢失和确认迟到](verify_lost_and_verify_late.png)

可以看出这样的协议发送效率是很低的，所以在运输层不会使用这样的协议，介绍这个这是引出如果保证最简单的可靠传输要如何实现。


### 回退n帧ARQ协议

停止等待ARQ每次只能发送一个分组，这样的传输效率是很低的。而回退n帧允许接收方每次发送连续的若干个分组，这样就大大提高了传输效率。

具体的原理如下图，回退n帧ARQ协议维护一个发送窗口，在该窗口内的分组都可以连续发送出去，发送方每收到窗口最左边分组的确认，就可以将窗口往右移动。如果原来发送了连续的5个分组，那么现在就可以发送第6个分组了。

![回退n帧ARQ协议](go_back_n.png)

接收方一般是采用**累积确认**的方式，也就是说接收方没必要对每个接收到的分组都发送确认，而是可以在收到几个分组之后，对按序到达的最后一个分组发送确认。这就表示到这个分组位置，所有的分组都正确收到了。

**累积确认**也是有缺点的，如果发送方发送了5个分组，但是中间的第3个分组丢失了，那么接收方只能对第2个分组发送确认，表示第1个和第2个分组已经收到了。此时虽然接收方已经收到了第4个和第5个分组，但是发送方仍旧会重传第3、4、5个分组。这就叫做go-back-n，表示需要再退回来重传已经发送过的n个分组。

现在的TCP/IP协议好像就是使用回退n帧ARQ协议。

## 流量控制
在回退n帧ARQ协议中，如果窗口越大，那么就能够在收到接收方的确认之前连续发送更多的分组。从而获得更高的传输效率。

但是如果发送方的发送速度过快，导致接收方来不及接收，这样不但没有提高效率，而且还会浪费发送方的资源。所以就需要进行流量控制，即让发送方的发送速率不要太快，要让接收方来的及接收。

### 流量控制的原理

所以发送方与接收方要在建立连接时协商窗口的大小，而且在通信的过程中也要时刻调整双方窗口的大小。

发端窗口的大小取决于收端的窗口大小rwnd（TCP报文的窗口大小字段）和拥塞窗口大小cwnd（见拥塞控制）发端窗口大小 = min{ rwnd , cwnd };

### 流量控制所引发的问题
假设B在发送确认报文给A时，将自身的窗口大小rwnd调整为0，即告诉A不要再发送数据了，我暂时不想接收数据，等到B想要接收数据时就会发送一个非零窗口的通知给A，假设这个非零窗口通知丢失了，那么就会发生死锁。即A在等待B发送非零窗口通知，而B在等待A发送数据。

为了解决这个问题，TCP为每个连接都设定一个**坚定计时器（Persistence timer）**。只要TCP连接的一方收到了零窗口通知，就启动周期性的坚定计时器，该计时器会周期性发送**零窗口探测报文**。而对方就会在确认这个报文的时候给出窗口值，如果窗口值不是零，那么打破了死锁的僵局。

> **零窗口探测报文**携带一个字节的数据，不可以不携带数据，因为在TCP连接过程中发送的报文的ACK字段必须被置为1，如果报文不携带数据，那么该报文就是确认报文，对方是不会对确认报文发出确认的。

### Nagle算法

TCP存在一个**small-packet problem**，如果TCP用来传输交互数据，比如说远程连接一台服务器，然后每敲击一次键盘就要将敲击的字符发送到该服务器。那么每次会发送长度为41字节的TCP报文（其中1各字节是数据，40字节是首部），这在轻负载的网络环境下是可以容忍的；但是如果在重负载的网络环境下，每次敲击键盘都发送这样的**small-packet**，就会导致报文的丢失和重传，所以需要减少发送到网络中的小包。

解决的方法就是TCP不是立马发送应用程序发来的数据，而是等待一段时间（200-500ms）再发送，这样的好处是将用户之后发来的数据合并起来，从而避免了小包。

在TCP的中广泛使用**Nagle**算法，该算法的实现如下：
+ 若应用程序发送了少量的数据到TCP的发送缓存中，那么TCP缓存暂时不发送这些数据，直到远端的主机发来了确认报文。
+ 如果远端主机发来了确认报文，那么就发送缓存中的数据。
+ 如果该连接是一个空闲连接，远端主机是不会发送确认报文过来的，这会造成死锁。所以如果该连接是空闲连接，那么不缓冲应用程序发来的数据，直接发送。
+ 如果缓存中的数据的大小超过了最大报文长度MSS，那么就立即发送一个报文段（因为这不是小包）。

具体的伪代码如下：
```python
if there is new data to send: #如果有新数据要发送
  if the window size >= MSS and available data is >= MSS: #数据的长度达到最大报文段
    send complete MSS segment now #发送数据
  else:
    if there is unconfirmed data still in the pipe: #如果仍旧有报文段没有收到确认
	#那么就将数据放入buffer中，直到收到一个新的确认才发送
      enqueue data in the buffer until an acknowledge is received 
    else:
      send data immediately #所有的报文都收到了确认，说明这是这个空闲连接，立即发送数据。
```

使用Nagle算法虽然提高了整个网络的吞吐量，但是降低了数据传输的实时性，这对具有很强实时性的应用来说是很不好的。Nagle算法是默认开启的，不过还好，可以通过设置**TCP_NODELAY**选项来禁用Nagle算法。

### 延迟确认算法

TCP收到一个报文之后不会立即发送确认，而是会在以下两种情况发送时发送确认：
1. 如果接收方此时要发送数据，那么将数据和确认报文合成一个报文发送。
2. 延迟确认算法的延迟计时器过期，那么立即发送对该报文的确认报文。

延迟确认算法的延迟一般初始化为最小值为**40ms**，但是会经过一定的算法进行调整，另外可以通过设置**TCP_QUICKACK**选项来取消延迟确认。


### Nagle算法与延迟确认算法所引起的后果
如果Nagle算法和延迟确认算法同时开启，可能会使时延增大。Nagle算法要求收到一个分组的ACK之前，不能发送其它小的数据包。所以尽管发送端的数据已经准备好了，但是由于接收方因为延迟确认算法没有发送对上一个分组的确认，导致数据迟迟不能发送。
<br />
参考：
+ [ARQ与滑动窗口协议](http://blog.csdn.net/jmq_0000/article/details/7299910)
+ [TCP协议中的计时器](http://www.tuicool.com/articles/bQfmUv)
+ [Nagle's algorithm](https://en.wikipedia.org/wiki/Nagle%27s_algorithm)
+ [ TCP/IP延迟确认和Nagle算法](http://blog.csdn.net/m_vptr/article/details/7093553)
+ [Nagle算法](http://blog.csdn.net/cylan_jia/article/details/7976051)
+ [再次谈谈TCP的Nagle算法与TCP\_CORK选项](http://blog.csdn.net/dog250/article/details/21303679)
