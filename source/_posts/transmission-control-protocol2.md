---
title: 传输控制协议（2）可靠传输
date: 2016-08-11 21:48:53
tags:
- 运输层
- TCP

categories:
- 计算机网络
---


## TCP如何保证可靠传输

要保证可靠传输，那么就要保证下面这两个条件成立

1. 传输信道不会产生差错
2. 不管发送方以多快的速率发送数据，接收方总是来得即处理接收到的数据。

<!-- more -->
但是这两个条件是不会成立的。但是我们可以通过一些协议，使得

1. 当出现差错时，让发送方重传出现差错的数据。 简单得来说就是**超时重传**。
2. 接收方来不及处理数据时，及时告诉发送方适当降低发送数据的速度。  简单得来说就是**流量控制**。


## 超时重传
TCP要求接收方对收到的每个分组都发送一个确认报文。
TCP会对每个发送的分组启动一个**超时计时器**，如果在超时计时器到期之前收到了对方的确认，那么就会撤销计时器；如果在超时计时器到期之前还没有收到对方的确认报文，就会重发该分组。所以

+ 发送方必须保留每个发送分组的副本，直到收到对方发来的对于该分组的确认报文，才能够丢弃该报文。
+ 超时计时器设置的重传时间应该比分组传输的**平均往返时间**更长一些。该超时时间选择肯定不是一个定值，而是通过一个自适应算法计算出来的。

这种自动重传分组的协议成为ARQ(Automatic Repeat reQuset)协议，即接收方不用请问发送方重传某个出错的分组。

**ARP协议分为停止等待(stop-and-wait)ARQ、回退n帧(go-back-n)ARQ、选择性重传(selective repeat)ARQ。**

后两种ARQ又叫做连续ARQ，因为后两种ARQ允许同时发送连续的若干个分组。
### 停止等待ARQ协议

停止等待ARQ协议如下图非常简单，A发送一个分组给B，如果A没有接收到B对于该分组的确认报文，那么就不会继续发送下一个分组，如果在超时时间内收到了确认报文，那么就继续发送下一个分组；如果在超时时间内没有收到该分组的确认报文，那么就重传该分组。

![停止等待协议](stop_waitting_protocol.png)

如果B收到了A发送的报文M1，并且发送了对M1报文的确认报文，但是该确认报文在传输过程中丢失了或者迟到了。那么该怎么处理呢？
+ 确认丢失：那么A会重传报文M1，B接收到M1后就知道A没有收到确认报文，所以就重发确认报文，并且丢弃这个重复的M1分组。
+ 确认迟到：在超时计时器的期限内没有收到对报文M1的确认报文，那么A会重传报文M1，B接收到M1后就知道A没有收到确认报文，所以重发确认报文，并且丢弃这个重复的M1报文。那么A可能会收到两个对M1的确认报文，那么A只要丢弃重复的确认报文即可。

![确认丢失和确认迟到](verify_lost_and_verify_late.png)

可以看出这样的协议发送效率是很低的，所以在运输层不会使用这样的协议，介绍这个这是引出如果保证最简单的可靠传输要如何实现。


### 回退n帧ARQ协议

停止等待ARQ每次只能发送一个分组，这样的传输效率是很低的。而回退n帧允许接收方每次发送连续的若干个分组，这样就大大提高了传输效率。

具体的原理如下图，回退n帧ARQ协议维护一个发送窗口，在该窗口内的分组都可以连续发送出去，发送方每收到窗口最左边分组的确认，就可以将窗口往右移动。如果原来发送了连续的5个分组，那么现在就可以发送第6个分组了。

![回退n帧ARQ协议](go_back_n.png)

接收方一般是采用**累积确认**的方式，也就是说接收方没必要对每个接收到的分组都发送确认，而是可以在收到几个分组之后，对按序到达的最后一个分组发送确认。这就表示到这个分组位置，所有的分组都正确收到了。

**累积确认**也是有缺点的，如果发送方发送了5个分组，但是中间的第3个分组丢失了，那么接收方只能对第2个分组发送确认，表示第1个和第2个分组已经收到了。此时虽然接收方已经收到了第4个和第5个分组，但是发送方仍旧会重传第3、4、5个分组。这就叫做go-back-n，表示需要再退回来重传已经发送过的n个分组。

现在的TCP/IP协议好像就是使用回退n帧ARQ协议。

## 流量控制
在回退n帧ARQ协议中，如果窗口越大，那么就能够在收到接收方的确认之前连续发送更多的分组。从而获得更高的传输效率。

但是如果发送方的发送速度过快，导致接收方来不及接收，这样不但没有提高效率，而且还会浪费发送方的资源。所以就需要进行流量控制，即让发送方的发送速率不要太快，要让接收方来的及接收。

### 流量控制的原理

所以发送方与接收方要在建立连接时协商窗口的大小，而且在通信的过程中也要时刻调整双方窗口的大小。

发端窗口的大小取决于收端的窗口大小rwnd（TCP报文的窗口大小字段）和拥塞窗口大小cwnd（见拥塞控制）发端窗口大小 = min{ rwnd , cwnd };

### 流量控制所引发的问题
假设B在发送确认报文给A时，将自身的窗口大小rwnd调整为0，即告诉A不要再发送数据了，我暂时不想接收数据，等到B想要接收数据时就会发送一个非零窗口的通知给A，假设这个非零窗口通知丢失了，那么就会发生死锁。即A在等待B发送非零窗口通知，而B在等待A发送数据。

为了解决这个问题，TCP为每个连接都设定一个**坚定计时器（Persistence timer）**。只要TCP连接的一方收到了零窗口通知，就启动周期性的坚定计时器，该计时器会周期性发送**零窗口探测报文**。而对方就会在确认这个报文的时候给出窗口值，如果窗口值不是零，那么打破了死锁的僵局。

> **零窗口探测报文**携带一个字节的数据，不可以不携带数据，因为在TCP连接过程中发送的报文的ACK字段必须被置为1，如果报文不携带数据，那么该报文就是确认报文，对方是不会对确认报文发出确认的。


<br />
参考：
+ [ARQ与滑动窗口协议](http://blog.csdn.net/jmq_0000/article/details/7299910)
+ [TCP协议中的计时器](http://www.tuicool.com/articles/bQfmUv)
